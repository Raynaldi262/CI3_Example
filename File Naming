1. File Naming
    Class files must be named in a Ucfirst-like manner, while any other file name (configurations, views, generic scripts, etc.)
    should be in all lowercase.
    Example
      incorect
        somelibrary.php
        someLibrary.php
        SOMELIBRARY.php
        Some_Library.php

        Application_config.php
        Application_Config.php
        applicationConfig.php

      Correct
        Somelibrary.php
        Some_library.php

        applicationconfig.php
        application_config.php

2. Class and Method Naming
     - Class names should always start with an uppercase letter. Multiple words should be separated with an underscore, and not CamelCased
       Example
        incorrect
          class superclass
          class SuperClass

         Correct
          class Super_class

      - Class methods should be entirely lowercased and named to clearly indicate their function, preferably including a verb. 
        Try to avoid overly long and verbose names. Multiple words should be separated with an underscore.
        Example
          Incorrect 
            function fileproperties()               // not descriptive and needs underscore separator
            function fileProperties()               // not descriptive and uses CamelCase
            function getfileproperties()            // Better!  But still missing underscore separator
            function getFileProperties()            // uses CamelCase
            function get_the_file_properties_from_the_file()        // wordy

          Correct
            function get_file_properties()  // descriptive, underscore separator, and all lowercase letters

3. Variabels Names
    Variables should contain only lowercase letters, use underscore separators, and be reasonably named to indicate their purpose and contents. 
    Very short, non-word variables should only be used as iterators in for() loops.

    Example
      Incorrect
        $j = 'foo';             // single letter variables should only be used in for() loops
        $Str                    // contains uppercase letters
        $bufferedText           // uses CamelCasing, and could be shortened without losing semantic meaning
        $groupid                // multiple words, needs underscore separator
        $name_of_last_city_used // too long
      
      Correct
        for ($j = 0; $j < 10; $j++)
        $str
        $buffer
        $group_id
        $last_city

4. Commenting
    Use single line comments within code, leaving a blank line between large comment blocks and code.
    Example 
      // break up the string by newlines
      $parts = explode("\n", $str);

      // A longer comment that needs to give greater detail on what is
      // occurring and why can use multiple single-line comments.  Try to
      // keep the width reasonable, around 70 characters is the easiest to
      // read.  Don't hesitate to link to permanent external resources
      // that may provide greater detail:
      //
      // http://example.com/information_about_something/in_particular/

      $parts = $this->foo($parts);


5. Constants
	Constants follow the same guidelines as do variables, except constants should always be fully uppercase.
	Always use CodeIgniter constants when appropriate, i.e. SLASH, LD, RD, PATH_CACHE, etc.
	Example
		Correct
			MY_CONSTANT
			NEWLINE
			SUPER_CLASS_VERSION
			$str = str_replace(LD.'foo'.RD, 'bar', $str);

6. True, False, Null
	TRUE, FALSE, and NULL keywords should always be fully uppercase
	CORRECT
		if ($foo == TRUE)
		$bar = FALSE;
		function foo($bar = NULL)

7. Logical Operators
	Use of the || “or” comparison operator is discouraged, as its clarity on some output devices is low (looking like the number 11, for instance). 
	&& is preferred over AND but either are acceptable, 
	and a space should always precede and follow !.
	Correct
		if ($foo OR $bar)
		if ($foo && $bar) // recommended
		if ( ! $foo)
		if ( ! is_array($foo))
	
	// PENTINGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG
8. Comparing return values and typecasting
	Some PHP functions return FALSE on failure, but may also have a valid return value of “” or 0, which would evaluate to FALSE in loose comparisons
	Use the same stringency in returning and checking your own variables. Use === and !== as necessary.
		Correct
			- if (strpos($str, 'foo') === FALSE)
			
			- function build_string($str = "")
			  {
					if ($str === "")
					{

					}
			  }

			- str = (string) $str; // cast $str as a string




